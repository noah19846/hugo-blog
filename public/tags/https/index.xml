<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>HTTPS - Tag - Kisama&#39;s Blog</title>
        <link>https://moshimoshi.top/tags/https/</link>
        <description>HTTPS - Tag - Kisama&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 16 Jun 2021 17:46:19 &#43;0000</lastBuildDate><atom:link href="https://moshimoshi.top/tags/https/" rel="self" type="application/rss+xml" /><item>
    <title>HTTPS 笔记</title>
    <link>https://moshimoshi.top/posts/https-%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Wed, 16 Jun 2021 17:46:19 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/https-%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[基本概念 对称加密 加密和解密用的是同一个密钥。
非对称加密 加密和解密需要用到一对不同的密钥 A 和 B，其中可以被公开的称为公钥，不公开的称为私钥，用 A 加密的则必须由 B 来解密，反之亦然。
中间人攻击 客户端和服务端之间传输的消息被一个「中间人」截获，中间人冒充二者与对方交换信息而二者毫不知情。
散列 通过某种算法将，将任何一组任意长度的数据都转换成一个固定（ 多半如此）长度的散列值。可用于签名认证，来检查某段信息是否被修改。比如已知信息 A，按某种散列算法 M 散列后得到 α，即 M(A)=α，现得到信息 B 和 α，如果 M(B)=α 也成立，那么依赖这种散列算法 M 自身的特性，理论上我们就认为 A=B，即得到的信息与原始信息一致，在传输过程中没有被篡改。
HTTP 传输的不足之处 明文传输，容易被攻击。
HTTP 避免明文传输的解决方法 对传输的信息进行对称加密 首先客户端先向服务端请求密钥，服务端将密钥明文传输给客户端，以后二者发送信息前均用密钥加密，收到信息后均用密钥解密。看起来像是解决了明文传输的问题，但密钥本身就是用明文传输的，无法防止泄露，只要密钥泄露，加密等于没加密。
对传输的信息进行单向非对称加密 服务端生成一对密钥，将公钥明文传给客户端，客户端向服务端发送、接受信息时，使用公钥加、解密，服务端像客户端发送、接受消息时，使用私钥加、解密。这样一来，即便公钥泄露，也只有服务端发送的消息加密失效。因为私钥始终在服务端，得不到私钥，客户端发送给服务端的消息无法被解密。
对传输的信息进行双向非对称加密 客户端也生成一对公、私钥，将公钥发送给服务端，服务端用客户端的公钥加密，客户端用服务端的公钥加密，然后用各自的私钥解密，这样一来，即便传输过程中两个公钥都泄露，只要本地的私钥不泄露，双方交流的信息就不会泄露。
单向非对称加密 + 对称加密 虽然上面双向非对称加密的方法可以解决明文传输的问题，但是需要两对非对称密钥，未免有点繁琐，而且非对称加密所花费的时间也不可小觑。这样的话，我们是不是可以利用单向非对称加密「起码可以保证客户端使用服务端公钥加密之后发送给服务端的信息无法被解密」的这个特点做点什么？是的，可以通过公钥加密一个对称密钥发送给服务端，后续彼此的信息交流都用这个密钥进行加、解密，这样一来只需要服务端的一对非对称密钥和客户端生成一个对称秘钥即可解决明文传输的问题，显然会比双向非对称加密来的有效率。
但是「单向非对称加密 + 对称加密」也只是解决了避免明文传输的问题，都还没有考虑如果客户端收到的公钥压根儿就不是服务端的公钥要怎么办？或者如果避免那种情况发生？设想一下如果在客户端、服务端之间存在一个可以截获双方来往所有信息的「中间人」，这个时候这个中间人会好到只满足于「偷窥」以外什么都不做么？
只加密传输信息无法防止中间人攻击 拿上面最繁琐的双向非对称举例，
 客户端、服务端像彼此发送各自的公钥 A、B，但都被中间人截获，中间人以自己的公钥 C 顶替 A、B 客户端、服务端都收到中间人的公钥 C 客户端通过公钥 C 发送加密消息给服务端，但被中间人截获，（中间人使用自己的私钥解密，拿到信息后）通过服务端的公钥 B 冒充客户端发送加密消息给服务端 客户端收到消息后使用自己的私钥解密，然后用公钥 C 返回加密消息给客户端，依然被中间人截获，（中间人使用自己的私钥解密，拿到信息后）通过客户端的公钥 A 冒充服务端发送加密消息给客户端  这样客户端和服务端之间的通信完全被中间人截获，从而导致它们收到的信息完全有可能不是来自对方（假如这个中间人够坏的话），而双方毫不自知。所以，只要存在中间人，那么仅仅止步于加密是完全不够的。]]></description>
</item>
</channel>
</rss>
