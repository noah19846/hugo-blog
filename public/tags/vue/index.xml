<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Vue - Tag - Kisama&#39;s Blog</title>
        <link>https://moshimoshi.top/tags/vue/</link>
        <description>Vue - Tag - Kisama&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 26 Mar 2022 10:22:06 &#43;0000</lastBuildDate><atom:link href="https://moshimoshi.top/tags/vue/" rel="self" type="application/rss+xml" /><item>
    <title>Vue2.6 slot 笔记</title>
    <link>https://moshimoshi.top/posts/vue-slot-%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Tue, 21 Sep 2021 21:07:57 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vue-slot-%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[什么是 slot？——精确的定义不好下，可以类比为电脑主板上用于插网卡、内存条等各种硬件的那些东西。因为有那些插槽，人们可以在上面插上不同的网卡和内存条。
slot 有什么用？——先设想，如果没有 slot，那些硬件就必须集成在主板上，显然不是一种灵活的做法，slot 就赋予了这种灵活性。
拿电脑主板打比方后，Vue 的 slot 的作用也就是一样的：赋予组件直接将 vnode 填充到组件的渲染内容中特定地方的能力。slot 相关的用法 Vue 文档有详述，本篇主要记录 slot 的实现原理，v2.6 之前的 slot attribute 的即将废弃的写法不作讨论，主要说明 v-slot 写法的 slot。
renderSlot 先从有 slot 的组件的 render 方法说起，比如下面的组件：
&lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Hello' } &lt;/script&gt; 的 render 函数会是：
function() { var _vm = this var _h = _vm.$createElement var _c = _vm._self._c || _h return _c(&quot;div&quot;, [_vm._t(&quot;default&quot;)], 2) } 其中 _vm._t 就是 renderSlot]]></description>
</item>
<item>
    <title>Vue2 函数式组件</title>
    <link>https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/</link>
    <pubDate>Sun, 12 Sep 2021 21:30:42 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/</guid>
    <description><![CDATA[函数式组件简介  何为函数式组件？——当组件对应的 options 对象中 functional 属性值为 true 时，这个组件就是一个函数式组件 函数式组件与一般组件有何不同？——它没有响应式的数据（组件对应的 options 里没有 data、computed 等与 state 相关的属性）；也不像一般组件一样有通过 options 创建的 vm 实例（自然也没有那一系列的生命周期），所以在函数式组件内部的方法中也没有 this 可以访问，它所拥有的只是一个包含 props、children、slots、scopedSlots、parent、listeners、injections 属性的 functionalRenderContext 对象，这个对象供函数式组件的 render 方法访问，以达到父组件向其传值以及访问函数式组件渲染内容的目的 为什么要有函数式组件？——有些时候一个组件并不需要创建和维护自己的内部状态，而只用完全根据 props 的值来决定渲染的内容，创建 vm 会略显多余，此时则是函数式组件的用武之地，相比于创建 vm 实例并执行一系列生命周期 hooks，创建一个 functionalRenderContext 对象的开销则小得多  函数式组件内部机制 不管是何种组件，调用自身 render 方法的结果都是返回一个 vnode 实例用于 patch，函数式组件也不例外，与一般组件的 render 方法不同的是函数式组件的 render 方法多了个 functionalRenderContext 对象用来弥补没有与之对应的 vm 实例所带来的的不足：没有内部状态固然不用创建 vm，但与此同时 props、children 之类的东西也没了。所以函数式组件的内部机制主要在于 functionalRenderContext 对象的创建，也即对象包含的属性的创建。与函数式组件相关的源码大致如下：
function createComponent(Ctor, data, context, children, tag) { // ... const propsData = extractPropsFromVNodeData(data, Ctor, tag) if (Ctor.]]></description>
</item>
<item>
    <title>从 new Vue 到所有组件 mounted</title>
    <link>https://moshimoshi.top/posts/new-vue%E5%88%B0%E6%89%80%E6%9C%89%E7%BB%84%E4%BB%B6mounte/</link>
    <pubDate>Sun, 15 Nov 2020 17:40:32 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/new-vue%E5%88%B0%E6%89%80%E6%9C%89%E7%BB%84%E4%BB%B6mounte/</guid>
    <description><![CDATA[前言 在开始本篇之前：
  本篇的主要目的在于理解 mounted 的大致原理（mounted 之后的事不在本篇讨论之内）
  所用的 Vue 版本是 2.6.11，借以帮助理解的例子是 vue-cli 创建的简单 demo
  暂不理会包括但不仅限于 slot、函数式组件、服务端渲染以及其他一些不影响理解的特性
  贴出的代码并不完全与源码一模一样，在没有错误的前提下会有一些改动和删减（笔者认为这样做有助于理解）
  也不会逐行去解释代码，未提到的部分可以认为暂时不提也无大碍（如果真的不是因为粗心的话）
  然后，本篇所用的实例代码如下：
main.js
import Vue from &#39;vue&#39; import App from &#39;./App&#39; new Vue({ render: h =&gt; h(App) }).mount(&#39;#app&#39;) App.vue
&lt;template&gt; &lt;div&gt; &lt;div&gt;hello, {{ msg }}&lt;/div&gt; &lt;home&gt;&lt;/home&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import home from &#39;./home&#39; export default { name: &#39;App&#39;, components: { home }, data() { return { msg: &#39;app&#39; } } } &lt;/script&gt; home.]]></description>
</item>
<item>
    <title>Vue 应用部署在非根路径</title>
    <link>https://moshimoshi.top/posts/vue-%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E9%9D%9E%E6%A0%B9%E8%B7%AF%E5%BE%84/</link>
    <pubDate>Thu, 15 Oct 2020 17:40:32 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vue-%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E9%9D%9E%E6%A0%B9%E8%B7%AF%E5%BE%84/</guid>
    <description><![CDATA[注：此处 Vue App 指的是由 Vue-CLI 3 创建的单页面应用，部署应用的 Web 服务器为 Nginx。
正文 谈到部署前端应用，大概所有有过相关经历的开发者都不会对这个流程感到陌生：npm run build -&gt; dist 目录整个 copy （手动、脚本或 devops 流水线）到对应 Web 服务器的指定目录。
然后在浏览器上输入服务器的地址（不需要任何路径）就可以访问到部署的那个应用了，在应用里面，你也只是按照后台开发给你 API 路径（大概率是个不包括服务器地址的绝对路径）去请求对应的数据，好像也没有做什么特殊的事情，应用完全运行正常。
这一切看起来十分的自然和理所应当，后面你又以相同的方式开发、部署了多个类似的应用，这种在根路径上的部署，对你来说轻车熟路，一切都很顺利。直到有一天，因为防火墙、或者资金紧张或者其他随便的什么原因，你们所有那些应用在公网上全都只能通过某一台服务器（假设叫 outer）访问了，也就是说原先可以分别通过 http://addressN （N = 1, 2, 3&hellip;）被  访问的各个应用，现在只能通过 http://address/appN/ 来访问了。这个时候，你想了想好像跟之前没什么区别，（拿 app1 举例）只不过原先部署到 http://address1 的 app1 只能换个内部的服务器（假设叫 inner1）部署了，然后在你重新部署了之后，负责配置 http://address 服务器 Nginx 的人告诉你：我把所有 /app1/ 开头的请求都转到 inner1 上了，你现在看下通过 http://address/app1/ 是不是能访问到 app1。
你内心感觉应该没什么问题地在浏览器上访问了那个地址：浏览器 Tab 条上 app1 的页面 title 出来了，但是整个页面一片空白。然后你很熟练地打开了控制台的 Network 发现，那些 js 和 css 资源都是 404，你很快的察觉到原因是由于这些资源的路径有问题，它们的格式分别是 /js/xx.]]></description>
</item>
</channel>
</rss>
