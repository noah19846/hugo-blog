<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>函数式组件 - Tag - Kisama&#39;s Blog</title>
        <link>https://moshimoshi.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/</link>
        <description>函数式组件 - Tag - Kisama&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 12 Sep 2021 21:30:42 &#43;0000</lastBuildDate><atom:link href="https://moshimoshi.top/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/" rel="self" type="application/rss+xml" /><item>
    <title>Vue2 函数式组件</title>
    <link>https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/</link>
    <pubDate>Sun, 12 Sep 2021 21:30:42 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/</guid>
    <description><![CDATA[函数式组件简介  何为函数式组件？——当组件对应的 options 对象中 functional 属性值为 true 时，这个组件就是一个函数式组件 函数式组件与一般组件有何不同？——它没有响应式的数据（组件对应的 options 里没有 data、computed 等与 state 相关的属性）；也不像一般组件一样有通过 options 创建的 vm 实例（自然也没有那一系列的生命周期），所以在函数式组件内部的方法中也没有 this 可以访问，它所拥有的只是一个包含 props、children、slots、scopedSlots、parent、listeners、injections 属性的 functionalRenderContext 对象，这个对象供函数式组件的 render 方法访问，以达到父组件向其传值以及访问函数式组件渲染内容的目的 为什么要有函数式组件？——有些时候一个组件并不需要创建和维护自己的内部状态，而只用完全根据 props 的值来决定渲染的内容，创建 vm 会略显多余，此时则是函数式组件的用武之地，相比于创建 vm 实例并执行一系列生命周期 hooks，创建一个 functionalRenderContext 对象的开销则小得多  函数式组件内部机制 不管是何种组件，调用自身 render 方法的结果都是返回一个 vnode 实例用于 patch，函数式组件也不例外，与一般组件的 render 方法不同的是函数式组件的 render 方法多了个 functionalRenderContext 对象用来弥补没有与之对应的 vm 实例所带来的的不足：没有内部状态固然不用创建 vm，但与此同时 props、children 之类的东西也没了。所以函数式组件的内部机制主要在于 functionalRenderContext 对象的创建，也即对象包含的属性的创建。与函数式组件相关的源码大致如下：
function createComponent(Ctor, data, context, children, tag) { // ... const propsData = extractPropsFromVNodeData(data, Ctor, tag) if (Ctor.]]></description>
</item>
</channel>
</rss>
