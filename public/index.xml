<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Kisama&#39;s Blog</title>
        <link>https://moshimoshi.top/</link>
        <description>This is my cool site</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 31 Jul 2022 09:45:14 &#43;0000</lastBuildDate>
            <atom:link href="https://moshimoshi.top/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>CSAPP-chapter-01 note</title>
    <link>https://moshimoshi.top/posts/csap-chapter-01-note/</link>
    <pubDate>Sun, 31 Jul 2022 09:45:14 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/csap-chapter-01-note/</guid>
    <description><![CDATA[本章为一个关于计算机系统的概述，点明了本书的面向读者，以及读完本书所能非读者带去的好处。比如：一些避免由计算机表示数字的方式引起的数字错误的实用技巧、充分利用现代处理器和存储器的系统设计来优化 C 代码的小窍门、了解编译器如何实现过程调用以及利用这些知识来避免缓冲区溢出错误带来的安全漏洞、识别和避免链接时的错误、编写自己的 Unix shell 和动态存储分配包以及 Web 服务器、认识并发等。
1.1 信息就是位 + 上下文 对计算机而言，任何输入、输出都是 0/1 bit 序列，它由人设计并为其所用，这些比特序列以及对 bit 序列的解释方式即构成对人而言的信息。文本文件和二进制文件是以人的角度（即解释的方式）来区分的，若某个文件其对应的 bit 序列可以按某个规则解释为对人有意义的文本，那么这个文件就是文本文件，否则就是二进制文件。
1.2 程序被其他程序翻译成不同的格式 机器能懂的只有指令，C 语言是为了人的方便创造的语言，由 C 语言写就的源程序需要让机器执行则必须先转换为机器所能理解的指令。这中间的过程为：
 预处理：处理头文件 编译：源程序转化为汇编程序 汇编：将汇编程序转换为可重定向的目标程序（什么是可重定向？） 链接：汇编程序中可能调用了其他单独编译好的汇编目标文件，需要将被包含的目标文件合并到汇编程序中  1.3 了解编译系统是如何工作的大有益处 益处有：
 可以针对性的优化程序的性能：比如在达到统一个目的时，某种条件下使用某种语句会比另外的语句更高效 理解和避免链接时出现的错误：比如各种静态变量和全局变量的区别、静态库和动态库的区别等 避免安全漏洞：理解堆栈的原理和缓冲区益处的错误  1.4 处理器读取并解释存在内存中的指令 计算机的硬件组成部分主要包括：I/O （输入、输出）设备（比如键盘、鼠标、显示器）、主存、CPU；这些设备之间的数据传输注意通过一个叫「总线」的东西。程序运行时待执行的指令必须要（可能是从存储器）加载到主存中，CPU 根据当前的程序计数器存储的地址，执行待执行的指令，每执行一条指令后，程序计数器存储的内容就会更新为下一条待执行的指令的地址。
1.5 高速缓存至关重要 从 CPU 里的寄存器读写的速度和从内存里读写数据的速度是数量级的差别，从内存里读写数据的速度和从外存储器读写的速度也是数量级的差别，如果需要从慢速的存储器里频繁读取速度势必会降低计算机运行的效率，所以可以在快速和慢速存储器中间设置一个介于二者速度之间的存储器，这些存储器就是 cache，有了 cache 计算机存取数据的速率就会有所提升。
1.6 存储设备形成层次结构 CPU 里的寄存器、介于内存和内存中间的 cache、内存、介于内存和外存中间的二级存储器、外存等这一些列具有存储功能的器件就构成了计算机的存储器层次结构。它们存取速度由快到慢、存储空间由小到大，相同存储单位的造价由高到低
1.7 操作系统管理硬件 操作系统是介于应用程序和硬件之间的系统应用，其功能体现为向应用软件提供调用硬件的接口使得应用程序员不必关注与硬件交互的复杂细节，同时防止应用软件对硬件的滥用。主要通过三个抽象来实现：
 文件：对 「I/O 设备」 的抽象 虚拟内存：对文件和「主存」的抽象 进程：对虚拟内存和「CPU」的抽象  1.8 系统之间利用网络通信 在此之前都只涉及计算机对只被看做是一个孤立的硬、软件集合体，两台计算机之间同样可以通过网络来进行通信，可以发送数据给其他计算机，也可以从其他计算机接受数据，此种情况下网络亦可以视作是一种 I/O 设备。]]></description>
</item>
<item>
    <title>Ubuntu 20.04 新机安装前端相关应用的脚本</title>
    <link>https://moshimoshi.top/posts/ubuntu-20.04-%E6%96%B0%E6%9C%BA%E5%AE%89%E8%A3%85%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC/</link>
    <pubDate>Sun, 05 Jun 2022 10:31:05 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/ubuntu-20.04-%E6%96%B0%E6%9C%BA%E5%AE%89%E8%A3%85%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC/</guid>
    <description><![CDATA[新建一个 ubuntu 虚拟机到可以开始前端开发中间所需的基本步骤：
 更换系统镜像源 配置 git 信息，比如 committer 信息和个人常用的 alias（zsh 的 git 插件已经有这个功能，如果使用它的话可以不用自己配置） 安装 zsh 和 oh-my-zsh 以及常用的插件（由于 github 经常连不上，可以考虑 git clone 时更换 github 镜像源，但记得及时改回来） 安装 nvm 以及 nodejs 通过 npm 安装 yarn，配置 yarn 镜像源 通过 yarn 安装 nrm，配置 npm 镜像源 安装 vscode 以及常用插件  所需文件：
source.list，注释懒得删，这里是更换中科大的源
# deb cdrom:[Ubuntu 20.04.4 LTS _Focal Fossa_ - Release amd64 (20220223)]/ focal main restricted # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to # newer versions of the distribution.]]></description>
</item>
<item>
    <title>git 笔记</title>
    <link>https://moshimoshi.top/posts/git-%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Sat, 28 May 2022 16:44:12 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/git-%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[git 笔记 一个目录中包含名为 .git 的目录（同时这个目录里需要存在些特定的东西）时，即表示这个目录正被 git 管理，.git 目录包含的所有东西即为对应的 repository。当我们在某个目录下执行 git init 后，命令造成的结果就是为这个目录生成一个空的 repository，之后所有的 commit 都会被记录在 .git 目录中。一个刚刚初始化的 .git 目录包含 HEAD、description、config 三个文件和 objects、refs、hooks、info 四个目录，这里主要需要了解的是 HEAD、objects 和 refs。其中 HEAD 文件是一个文本文件，里面存储的是当前所在的 branch，可以通过 cat .git/HEAD 直接写查看它的内容：ref: refs/heads/master，表示当前正处于 master branch，可以说 HEAD 就是指向当前 branch 的一个 reference。而 refs 目录则是保存 branch 和 tag 等相关信息的地方，其中 branch 的信息保存在 refs/heads 目录下，一个 branch 就对应一个文本文件，文件的内容是一个 40 个字符的 hash 串（git 中生成 hash 的算法是 SHA-1），对应某个 commit，也即这个 branch 当前最新的一次 commit 的 id。比如上面 refs/heads/master 的即代表 master branch，如果新建一个 test branch，那么对应的在 refs/heads 目录下就会生成一个 test 文件。所以，所谓的 Branch 本质上就是一个指向某个 commit 的 reference（这个 reference 的形式是一个 hash）。同样，Tag 也是一个 reference，它的形式也是一个 hash，作为字符串存储在 refs/tag/{tag-name} 文件中，但是这个 hash 或如同 branch 一样指向一个 commit object，或指向一个包含某个 commit object 的 tag object。所以这保存 branch 和 tag 相关信息的目录名为 refs。]]></description>
</item>
<item>
    <title>Promise 简单实现</title>
    <link>https://moshimoshi.top/posts/promise-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</link>
    <pubDate>Sun, 17 Apr 2022 12:06:56 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/promise-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</guid>
    <description><![CDATA[原理：
 每个 promise 实例有 value，status，cbs 属性，其中 value 用于存储 resolve 或 reject 时的值，status 保存当前 promise 的状态，初始为 pending，cbs 为一个订阅当前 promise 实例状态的回调数组（初始为空），因为一个 promise 实例可多次调用 then 或 catch 创建一个新的 promise 时，初始化三个属性，以及将 _resolve 和 _reject 传给 new Promise 的参数函数当参数 _resolve 和 _reject 的处理非 promise 和非 thenable 以外的值逻辑大体一致，都是 setTimeout 后将当前的 promise 实例状态和值更新，以及查看是否有后续的 promise 订阅，有则依次执行对应回调，然后将回调队列置为空；_reject 函数多出来的逻辑是如果没有订阅则执行 throw value。回调队列为空的情况是，promise 状态变化时，还未有对之进行 then 或 catch 的调用 then 的逻辑：无论如何都其返回值都是一个新的 promise 实例。查看当前状态，如果不是 pending 则说明 promise 状态已经改变，然后根据对应的状态返回的新的 promise 实例的构造函数中执行 resolve 或 reject this.]]></description>
</item>
<item>
    <title>File API 相关笔记</title>
    <link>https://moshimoshi.top/posts/file-api-%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Sun, 03 Apr 2022 10:06:46 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/file-api-%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[概念  buffer：指的是内存里用于临时存储数据的区域。当数据生产者和消费者处理数据的速率不一致时，便需要 buffer，当然，这只是用途的应用之一。无论如何，其本质就是内存里的一段区域，我们可以对之进行读、写 ArrayBuffer：JavaScript 里的一种对象类型，用于创建固定长度原始数据缓冲区。比如代码 new ArrayBuffer(8) 就创建一个 ArrayBuffer 实例，对应一个长度为 8 byte 的 buffer，但是 ArrayBuffer 实例本身没有提供读、写 buffer 的途径 TypedArray：JavaScript 中一系列的对象类型（比如 Uint8Array、Int16Array 等）的统称，这些对象类型对应的对象内部都关联一个 ArrayBuffer 实例，TypedArray 实例则可以对由它们创建的 buffer 进行读写，直接像操作数组一样，通过下标赋值、取值 DataView: 与 TypedArray 类似，是 JavaScript 的另一个提供读写 buffer 底层接口的对象类型，其对 buffer 的读写不用关注代码所运行的平台的大、小端类型  TypedArray 和 DataView 实例都与一个 ArrayBuffer 实例相关联，每个 ArrayBuffer 实例都对应一个特定字节数的 buffer，但 ArrayBuffer 实例本身没有接口去读写这些 buffer，TypedArray 和 DataView 实例便提供了途径去读写，但针对不同类型的数据（比如操作一个 ASCII 码字符串就可以使用 Uint8Array，而对一些范围在 0 到 65535 的整数就可以用 Uint16Array），开发者可以依据自己的需求使用不同的 TypedArray。
总而言之，在 JavaScript 中只要是读写 buffer 的必定离不开某个 ArrayBuffer 实例。]]></description>
</item>
<item>
    <title>vite 项目中 debug vue3.x 源码</title>
    <link>https://moshimoshi.top/posts/vite-%E9%A1%B9%E7%9B%AE%E4%B8%AD-debug-vue3.x-%E6%BA%90%E7%A0%81/</link>
    <pubDate>Sat, 26 Mar 2022 10:22:06 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vite-%E9%A1%B9%E7%9B%AE%E4%B8%AD-debug-vue3.x-%E6%BA%90%E7%A0%81/</guid>
    <description><![CDATA[之前在 vue-cli 创建的项目中调试 Vue2.x 源码时，只修改 package.json 中 module 字段对应的文件内容，对应的改动就会在浏览器刷新后体现出来，但这在由 vite 创建的 vue3.x 的项目中却行不通，原因有三：
 vue3.x 是一个 monorepo，源码被分成了好几部分 vite 的 pre-bundle 机制 vite 设置的浏览器缓存机制  后面两个好解决，只需分别将创建 viteServer 的 server.force 设置为 true（即将 package.json 里 scripts 中 &quot;dev&quot;: &quot;vite&quot; 改为 &quot;dev&quot;: &quot;vite --forece&quot;） 和浏览器控制台 network 栏激活 Disable cache 即可，这两步完成之后其实就可以在浏览器中调试源码了：
 修改 vue3.x package.json 中 module 字段对应的文件，以及其 dependencies 的 package.json 中 module 字段对应的文件 在编辑器中手动保存（不用任何改动，只在那个文件窗口下 cmd + s 即可）一下 vite.config.js 文件  这两步之后即可看到源码中的改动体现在浏览器中了，所以，这就完了？
当然不是，天知道每次改动一个文件之后还要再到另一个文件窗口中按一下 cmd + s 才能让浏览器刷新有多憨批，所以自动保存 vite.]]></description>
</item>
<item>
    <title>CSS 规范相关一点杂记</title>
    <link>https://moshimoshi.top/posts/css-%E8%A7%84%E8%8C%83%E7%9B%B8%E5%85%B3%E4%B8%80%E7%82%B9%E6%9D%82%E8%AE%B0/</link>
    <pubDate>Sat, 25 Dec 2021 18:02:42 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/css-%E8%A7%84%E8%8C%83%E7%9B%B8%E5%85%B3%E4%B8%80%E7%82%B9%E6%9D%82%E8%AE%B0/</guid>
    <description><![CDATA[规范本身相关  制定规范的工作由一个叫 W3C 的组织承担 即便是那些与规范有关联的文档，也不一定就是标准，从规范文档到最终称为推荐标准，中间会经过一系列流程，从最初的 Draft 状态到最终 Recommendation 状态 而且已经是 Recommendation 状态的也不一定就是一成不变，随着 Web 的发展，后续可能会被别的规范所更新 在 CSS3 及其以前，CSS 的规范都是作为一个整体统一演进，比如 CSS2 到 CSS3 即是 CSS 从 level 2 更新到 level 3，但从那以后 CSS 规范被分为不同的模块独立更新，所以从此便没有 CSS level 4 一说，有的只是 CSS module level 一般 W3C 会在每年年末的时候发布一个关于当年 CSS 规范更新工作的 snapshot，通过这个总览一些相关的信息  css current work https://www.w3.org/Style/CSS/current-work
How to Read W3C Specs https://alistapart.com/article/readspec/
Understanding the CSS Specifications https://www.w3.org/Style/CSS/read
Visual Formatting Model 相关  CSS 按照一系列特定的规则将 由 element 和 text 组成的 DOM tree 转换成 box tree，这些特定规则就是所谓的 visual formatting model。DOM 上需要在浏览器上渲染出来的东西都对应 box tree 上的某个（或些） box 一个 element 可能会创建多个 box，比如 display 值为 list-item 的会创建两个 box，其中包含子 box 的那个被称为 principal box 引用一个 box 的 CSS 某个属性，即是指创建它的那个 element 对应的 CSS 属性 浏览器的 media type 是 screen，除此之前了 CSS 规范还包含其他的 CSS 属性，比如 print、tty 等其他各式 media type 暂时只考虑 media type 为 screen 的浏览器，对应的 root element 则指 html 元素  概念 Display 属性的值 实际上目前 box 的 display 属性值都是缩写，各种值其实蕴含 inner display type 和 outer display type 两种，outer display type 则分为 block 和 inline 两种（不考虑 run-in），它的取值决定了它自身是参与怎样的 formatting context 在其 containing block 中进行 layout 的；而 inner display type 就分好多种了，比如 table、flex、flow 等，它的取值决定了其包含的内容在其内部是以何种规则进行 layout 的。平时写的 display 值为 block、flex、inline 等其实都是只指明了一种 type 的缩写，只需要只定义一种是因为另一种 type 已经由 CSS 规范规定好，比如 block 值实际的意义是 inner type 为 flow 且 outer type 为 block，而 flex 的值意义为 inner type 为 flex 且 outer type 为 block。]]></description>
</item>
<item>
    <title>window 下的 api 分类整理笔记</title>
    <link>https://moshimoshi.top/posts/window-%E4%B8%8B%E7%9A%84-api-%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Sat, 18 Dec 2021 13:21:22 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/window-%E4%B8%8B%E7%9A%84-api-%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[window 下的 api 主要分为 ECMAScript API、DOM API、HTML API（其实很多 API 都算是包含在 HTML API 里的，只不过被细分出来，比如 DOM API）、CSSOM 相关的 API，以及剩余的占绝大多数的 Web api（有被纳入规范的和未被纳入规范的，这些 API 都是为浏览器提供特定的功能，比如音视频相关、蓝牙相关等）。这些 Web API 由可能最先由某个组织（比如 W3C、WHATWG、WICG 等）提出，然后被浏览器厂商实现（不一定被纳入标准）。
CSSOM View API 为 DOM 的 element 扩展了一些与 view 相关的（比如距离、长宽之类）的属性和方法。
// appVersion: &quot;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.93 Safari/537.36&quot; ;(function f() { const allPropsNames = { ecma: [ 'Object', 'Function', 'Array', 'Number', 'parseFloat', 'parseInt', 'Infinity', 'NaN', 'undefined', 'Boolean', 'String', 'Symbol', 'Date', 'Promise', 'RegExp', 'Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError', 'AggregateError', 'globalThis', 'JSON', 'Math', 'Intl', 'ArrayBuffer', 'Uint8Array', 'Int8Array', 'Uint16Array', 'Int16Array', 'Uint32Array', 'Int32Array', 'Float32Array', 'Float64Array', 'Uint8ClampedArray', 'BigUint64Array', 'BigInt64Array', 'DataView', 'Map', 'BigInt', 'Set', 'WeakMap', 'WeakSet', 'Proxy', 'Reflect', 'Atomics', 'FinalizationRegistry', 'WeakRef', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape', 'unescape', 'eval', 'isFinite', 'isNaN' ], dom: [ 'Event', 'CustomEvent', 'EventTarget', 'AbortController', 'AbortSignal', 'NodeList', 'HTMLCollection', 'MutationObserver', 'MutationRecord', 'Node', 'Document', 'DOMImplementation', 'DocumentType', 'DocumentFragment', 'ShadowRoot', 'Element', 'NamedNodeMap', 'Attr', 'CharacterData', 'Text', 'CDATASection', 'ProcessingInstruction', 'Comment', 'AbstractRange', 'StaticRange', 'Range', 'NodeIterator', 'TreeWalker', 'NodeFilter', 'DOMTokenList', 'XPathResult', 'XPathExpression', 'XPathEvaluator', 'XSLTProcessor', 'DOMError', 'XMLDocument' ], html: [ 'BarProp', 'BeforeUnloadEvent', 'BroadcastChannel', 'CanvasGradient', 'CanvasPattern', 'CanvasRenderingContext2D', 'CloseEvent', 'CustomElementRegistry', 'DOMParser', 'DOMStringList', 'DOMStringMap', 'DataTransfer', 'DataTransferItem', 'DataTransferItemList', 'DragEvent', 'ElementInternals', 'ErrorEvent', 'EventSource', 'External', 'FormDataEvent', 'HTMLDocument', 'HTMLAllCollection', 'HTMLAnchorElement', 'HTMLAreaElement', 'HTMLAudioElement', 'HTMLBRElement', 'HTMLBaseElement', 'HTMLBodyElement', 'HTMLButtonElement', 'HTMLCanvasElement', 'HTMLDListElement', 'HTMLDataElement', 'HTMLDataListElement', 'HTMLDetailsElement', 'HTMLDialogElement', 'HTMLDirectoryElement', 'HTMLDivElement', 'HTMLElement', 'HTMLEmbedElement', 'HTMLFieldSetElement', 'HTMLFontElement', 'HTMLFormControlsCollection', 'HTMLFormElement', 'HTMLFrameElement', 'HTMLFrameSetElement', 'HTMLHRElement', 'HTMLHeadElement', 'HTMLHeadingElement', 'HTMLHtmlElement', 'HTMLIFrameElement', 'HTMLImageElement', 'HTMLInputElement', 'HTMLLIElement', 'HTMLLabelElement', 'HTMLLegendElement', 'HTMLLinkElement', 'HTMLMapElement', 'HTMLMarqueeElement', 'HTMLMediaElement', 'HTMLMenuElement', 'HTMLMetaElement', 'HTMLMeterElement', 'HTMLModElement', 'HTMLOListElement', 'HTMLObjectElement', 'HTMLOptGroupElement', 'HTMLOptionElement', 'HTMLOptionsCollection', 'HTMLOutputElement', 'HTMLParagraphElement', 'HTMLParamElement', 'HTMLPictureElement', 'HTMLPreElement', 'HTMLProgressElement', 'HTMLQuoteElement', 'HTMLScriptElement', 'HTMLSelectElement', 'HTMLSlotElement', 'HTMLSourceElement', 'HTMLSpanElement', 'HTMLStyleElement', 'HTMLTableCaptionElement', 'HTMLTableCellElement', 'HTMLTableColElement', 'HTMLTableElement', 'HTMLTableRowElement', 'HTMLTableSectionElement', 'HTMLTemplateElement', 'HTMLTextAreaElement', 'HTMLTimeElement', 'HTMLTitleElement', 'HTMLTrackElement', 'HTMLUListElement', 'HTMLUnknownElement', 'HTMLVideoElement', 'HashChangeEvent', 'History', 'ImageBitmap', 'ImageBitmapRenderingContext', 'ImageData', 'Location', 'MediaError', 'MessageChannel', 'MessageEvent', 'MessagePort', 'MimeType', 'MimeTypeArray', 'Navigator', 'OffscreenCanvas', 'OffscreenCanvasRenderingContext2D', 'PageTransitionEvent', 'Path2D', 'Plugin', 'PluginArray', 'PopStateEvent', 'PromiseRejectionEvent', 'RadioNodeList', 'SharedWorker', 'Storage', 'StorageEvent', 'SubmitEvent', 'TextMetrics', 'TextTrack', 'TextTrackCue', 'TextTrackCueList', 'TextTrackList', 'TimeRanges', 'TrackEvent', 'ValidityState', 'WebSocket', 'Window', 'Worker', 'Worklet', 'Option', 'Image', 'Audio' ], cssom: [ 'MediaList', 'getComputedStyle', 'StyleSheet', 'CSSStyleSheet', 'StyleSheetList', 'CSSRuleList', 'CSSRule', 'CSSStyleRule', 'CSSImportRule', 'CSSGroupingRule', 'CSSPageRule', 'CSSNamespaceRule', 'CSSStyleDeclaration', 'CSS', 'CSSMediaRule', 'CSSConditionRule', 'CSSSupportsRule', 'MediaQueryListEvent', 'MediaQueryList', 'scroll', 'screenLeft', 'screenTop' ], cssomView: [ 'matchMedia', 'screen', 'moveTo', 'moveBy', 'scrollTo', 'scrollBy', 'resizeTo', 'resizeBy', 'innerWidth', 'innerHeight', 'scrollX', 'pageXOffset', 'scrollY', 'pageYOffset', 'screenX', 'screenY', 'outerWidth', 'outerHeight', 'devicePixelRatio', 'Screen' ], xmlHttpRequest: [ 'FormData', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload', 'ProgressEvent' ], fetch: ['fetch', 'Response', 'Request', 'Headers'], webgl: [ 'WebGLBuffer', 'WebGLFramebuffer', 'WebGLProgram', 'WebGLRenderbuffer', 'WebGLShader', 'WebGLTexture', 'WebGLUniformLocation', 'WebGLActiveInfo', 'WebGLShaderPrecisionFormat', 'WebGLRenderingContext', 'WebGLContextEvent', 'WebGLQuery', 'WebGLSampler', 'WebGLSync', 'WebGLTransformFeedback', 'WebGLVertexArrayObject', 'WebGL2RenderingContext' ], worker: [ 'ServiceWorker', 'ServiceWorkerContainer', 'ServiceWorkerRegistration', 'NavigationPreloadManager' ], cssTypedOm: [ 'CSSStyleValue', 'StylePropertyMapReadOnly', 'StylePropertyMap', 'CSSUnparsedValue', 'CSSVariableReferenceValue', 'CSSKeywordValue', 'CSSNumericValue', 'CSSUnitValue', 'CSSMathValue', 'CSSMathSum', 'CSSMathProduct', 'CSSMathNegate', 'CSSMathInvert', 'CSSMathMin', 'CSSMathMax', 'CSSNumericArray', 'CSSTransformValue', 'CSSTransformComponent', 'CSSTranslate', 'CSSRotate', 'CSSScale', 'CSSSkew', 'CSSSkewX', 'CSSSkewY', 'CSSPerspective', 'CSSMatrixComponent', 'CSSPositionValue', 'CSSImageValue' ], webIdl: ['DOMException'], url: ['URL', 'URLSearchParams'], streams: [ 'ReadableStream', 'ReadableStreamDefaultReader', 'ReadableStreamBYOBReader', 'ReadableStreamDefaultController', 'ReadableByteStreamController', 'ReadableStreamBYOBRequest', 'WritableStream', 'WritableStreamDefaultWriter', 'WritableStreamDefaultController', 'TransformStream', 'ByteLengthQueuingStrategy', 'CountQueuingStrategy' ], storage: ['StorageManager'], notification: ['Notification'], encode: [ 'TextDecoder', 'TextEncoder', 'TextDecoderStream', 'TextEncoderStream' ], backgroundFetch: [ 'BackgroundFetchManager', 'BackgroundFetchRegistration', 'BackgroundFetchRecord' ], backgroundTask: ['IdleDeadline'], bluetooth: [ 'Bluetooth', 'BluetoothCharacteristicProperties', 'BluetoothDevice', 'BluetoothRemoteGATTCharacteristic', 'BluetoothRemoteGATTDescriptor', 'BluetoothRemoteGATTServer', 'BluetoothRemoteGATTService', 'BluetoothUUID' ], cssRules: [ 'CSSPropertyRule', 'CSSKeyframesRule', 'CSSKeyframeRule', 'CSSFontFaceRule', 'CSSCounterStyleRule' ], fontFaceLoad: ['FontFaceSetLoadEvent', 'FontFace'], clipboard: ['Clipboard', 'ClipboardItem', 'ClipboardEvent'], credential: [ 'Credential', 'FederatedCredential', 'PasswordCredential', 'PublicKeyCredential' ], encryptedMediaExtensions: [ 'MediaKeys', 'MediaKeySession', 'MediaKeyStatusMap', 'MediaKeySystemAccess', 'MediaKeyMessageEvent', 'MediaEncryptedEvent' ], fileSystemAccess: [ 'FileSystemHandle', 'FileSystemFileHandle', 'FileSystemDirectoryHandle', 'FileSystemWritableFileStream', 'showOpenFilePicker', 'showSaveFilePicker', 'showDirectoryPicker' ], gamePad: [ 'Gamepad', 'GamepadButton', 'GamepadEvent', 'GamepadHapticActuator' ], geo: [ 'Geolocation', 'GeolocationCoordinates', 'GeolocationPosition', 'GeolocationPositionError' ], indexDB: [ 'IDBCursor', 'IDBCursorWithValue', 'IDBDatabase', 'IDBFactory', 'IDBIndex', 'IDBKeyRange', 'IDBObjectStore', 'IDBOpenDBRequest', 'IDBRequest', 'IDBTransaction', 'IDBVersionChangeEvent' ], mediaStream: [ 'BlobEvent', 'MediaDevices', 'MediaStream', 'MediaStreamTrack', 'MediaStreamTrackEvent' ], webVTT: ['VTTCue'], webHID: ['HID', 'HIDDevice', 'HIDInputReportEvent', 'HIDConnectionEvent'], webCodecs: [ 'AudioData', 'AudioDecoder', 'AudioEncoder', 'EncodedAudioChunk', 'EncodedVideoChunk', 'ImageDecoder', 'ImageTrack', 'ImageTrackList', 'VideoDecoder', 'VideoEncoder', 'VideoColorSpace', 'VideoFrame' ], webSpeech: [ 'SpeechSynthesisErrorEvent', 'SpeechSynthesisEvent', 'SpeechSynthesisUtterance' ], webMIDI: [ 'MIDIInputMap', 'MIDIOutputMap', 'MIDIAccess', 'MIDIPort', 'MIDIInput', 'MIDIOutput', 'MIDIMessageEvent', 'MIDIConnectionEvent' ], webCrypto: ['Crypto', 'CryptoKey', 'SubtleCrypto'], webAuth: [ 'CredentialsContainer', 'AuthenticatorResponse', 'AuthenticatorAttestationResponse', 'AuthenticatorAssertionResponse' ], webAudio: [ 'AnalyserNode', 'AudioBuffer', 'AudioBufferSourceNode', 'AudioContext', 'AudioDestinationNode', 'AudioListener', 'AudioNode', 'AudioParam', 'AudioProcessingEvent', 'AudioScheduledSourceNode', 'AudioWorklet', 'AudioWorkletNode', 'BaseAudioContext', 'BiquadFilterNode', 'ChannelMergerNode', 'ChannelSplitterNode', 'ConstantSourceNode', 'ConvolverNode', 'DelayNode', 'DynamicsCompressorNode', 'GainNode', 'IIRFilterNode', 'MediaElementAudioSourceNode', 'MediaStreamAudioDestinationNode', 'MediaStreamAudioSourceNode', 'OfflineAudioCompletionEvent', 'OfflineAudioContext', 'OscillatorNode', 'PannerNode', 'PeriodicWave', 'WaveShaperNode', 'StereoPannerNode' ], webAnimation: [ 'Animation', 'AnimationEffect', 'AnimationEvent', 'AnimationTimeline', 'AnimationPlaybackEvent', 'DocumentTimeline', 'KeyframeEffect' ], touchEvent: ['Touch', 'TouchEvent', 'TouchList'], serviceWorker: [ 'Cache', 'CacheStorage', 'PeriodicSyncManager', 'SyncManager' ], sensor: [ 'AbsoluteOrientationSensor', 'Accelerometer', 'GravitySensor', 'Gyroscope', 'LinearAccelerationSensor', 'OrientationSensor', 'RelativeOrientationSensor', 'Sensor', 'SensorErrorEvent' ], wakeLock: ['WakeLock', 'WakeLockSentinel'], payment: [ 'PaymentAddress', 'PaymentMethodChangeEvent', 'PaymentRequest', 'PaymentRequestUpdateEvent', 'PaymentResponse', 'PaymentManager', 'PaymentInstruments' ], presentation: [ 'Presentation', 'PresentationAvailability', 'PresentationRequest', 'PresentationConnectionAvailableEvent', 'PresentationConnection', 'PresentationConnectionCloseEvent', 'PresentationReceiver', 'PresentationConnectionList' ], geometry: [ 'DOMRectReadOnly', 'DOMRect', 'DOMRectList', 'DOMQuad', 'DOMMatrixReadOnly', 'DOMMatrix', 'DOMPointReadOnly', 'DOMPoint' ], trustedType: [ 'TrustedHTML', 'TrustedScript', 'TrustedScriptURL', 'TrustedTypePolicyFactory', 'TrustedTypePolicy' ], wasm: ['WebAssembly'], file: ['Blob', 'File', 'FileList', 'FileReader'], deviceOrientation: [ 'DeviceOrientationEvent', 'DeviceMotionEventAcceleration', 'DeviceMotionEventRotationRate', 'DeviceMotionEvent' ], push: ['PushManager', 'PushSubscription', 'PushSubscriptionOptions'], lqbz: [ .]]></description>
</item>
<item>
    <title>杂记</title>
    <link>https://moshimoshi.top/posts/%E6%9D%82%E8%AE%B0/</link>
    <pubDate>Fri, 05 Nov 2021 14:59:07 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/%E6%9D%82%E8%AE%B0/</guid>
    <description><![CDATA[杂 Q: source map 是什么？如何使用？
A: source map 一个保存转换前、后文件内容位置对应信息的 json 格式的文件。位置关系保存在 mapping 字段的值中，通过这个值和特定的算法可以从转化后的文件中的任意位置找到源文件中与之对应的位置，源文件内容存在于 sourcesContent 字段中。浏览器通过处理后的文件结尾的 //# sourceMappingURL=url 来加载对应的 map 文件，进而借之还原转换前的 js 文件，以便为开发者提供友好的调试体验。url 可以是一个指向某处 map 文件的资源连接，也可以是一个由对应内容转换的 base64 链接。像 rollup、webpack、esbuild 等 bundler 工具都支持 inline（对应打包后文件末尾注释的 base64） 和 external（对应独立的 map 文件）的生成方式。当一个支持 source map 的浏览器加载 map 文件后，当打包后文件报错时，浏览器可以从打包文件中的报错位置定位到源文件中对应的位置。
Q: CSP(Content Security Policy) 是什么？
A:
 CSP 是一系列检测（上报）和减轻特定类型的 Web 攻击（主要是 XSS）的策略，通过配置返回 html 文件时的 Content-Security-Policy: ${policy-token} header 或在返回的 html 文件中设置 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;${policy-token}&quot;&gt; 来生效 上述 policy-token 由一系列 directives 组成，每个 directives 通过 ; 分隔，directives 又由为 directive-name 和 directive-value 组成，ANBF 定义如下：  policy-token = [ directive-token *( &quot;;&quot; [ directive-token ] ) ] directive-token = *WSP [ directive-name [ WSP directive-value ] ] directive-name = 1*( ALPHA / DIGIT / &quot;-&quot; ) directive-value = *( WSP / &lt;VCHAR except &quot;;&quot; and &quot;,&quot;&gt; )   不支持 CSP 的浏览器默认使用同源策略。对于 web server 不返回 CSP header 的情况，浏览器也默认使用同源策略]]></description>
</item>
<item>
    <title>vue2 自定义指令笔记以及在埋点上的简单应用</title>
    <link>https://moshimoshi.top/posts/vue2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%9F%8B%E7%82%B9%E4%B8%8A%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</link>
    <pubDate>Sat, 25 Sep 2021 17:19:36 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vue2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%9F%8B%E7%82%B9%E4%B8%8A%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</guid>
    <description><![CDATA[简介 Vue 允许开发者注册自定义指令，可以是通过 Vue.directives 注册全局指令或是在组件的 options 里添加 directives 属性。前者接受两个参数，第一个参数是指令名，第二个参数是定义指令的值（可以是一个包含指令各个 hooks 的函数的对象或者是一个只对 bind 和 update hook 生效的简写函数），后者是一个包含以指令名为属性以及对应定义指令的值为值的对象。
指令 hook 函数和对应参数 定义指令的对象包括 bind、inserted、update、componentUpdated、unbind 五个 hook，每个 hook 对应一个在对应时机执行的函数，函数的参数为：
 el：含指令所绑定的 DOM 元素 binding：包含指令相关信息（包括指令名、绑定值、绑定的参数、修饰符等）的对象 vnode：指令被解析为其 data.directives 属性的 vnode oldVnode：更新前的 vnode，仅在 update、componentUpdated 有值  可以猜测指令只在一般组件和 HTML 元素上生效，而在函数式组件和像 template、slot、component 对应的标签以及 keep-alive、transition 这样 abstract 组件上不生效的，因为指令 hook 的第一个参数是一个 DOM 元素，后面的几种情况并不能永远确定一个唯一的 el 传给 hook。事实上通过从源码粗略搜索关键字也可以确认不适用指令的情况中，指令对应的 vnode.data.directives 并未被处理。
指令的大致机制 指令注册的机制 就是通过 Vue.directives 和 options.directives API 使得某个组件可以通过 vm.$options.directives.directiveName 可以访问到对应的指令对象。
指令作用的机制 通过搜索 directives 在 vdom 相关的模块可以知道「指令是通过 vdom 的 module 机制生效的」。vdom 的 module 是用于处理 vdom 的各种 attribute 的机制，比如 style、class、events 等，这些 module 如同定义指令的对象一样也是一个由一个个 hook 名和对应函数值组成的对象，只不过 module 的 hook 是 vdom 的 hook。通过在 vdom 的 hook 里触发指令对应的 hook 从而使指令生效。而触发指令 hook 的时对应函数的第二个参数 binding 相关的信息则由通过 template 模板编译（或是手写 render 直接传参）而来的 vnode.]]></description>
</item>
</channel>
</rss>
