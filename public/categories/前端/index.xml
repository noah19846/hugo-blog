<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>前端 - Category - Kisama&#39;s Blog</title>
        <link>https://moshimoshi.top/categories/%E5%89%8D%E7%AB%AF/</link>
        <description>前端 - Category - Kisama&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 25 Sep 2021 17:19:36 &#43;0000</lastBuildDate><atom:link href="https://moshimoshi.top/categories/%E5%89%8D%E7%AB%AF/" rel="self" type="application/rss+xml" /><item>
    <title>vue2 自定义指令笔记以及在埋点上的简单应用</title>
    <link>https://moshimoshi.top/posts/vue2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%9F%8B%E7%82%B9%E4%B8%8A%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</link>
    <pubDate>Sat, 25 Sep 2021 17:19:36 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vue2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%9F%8B%E7%82%B9%E4%B8%8A%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</guid>
    <description><![CDATA[简介 Vue 允许开发者注册自定义指令，可以是通过 Vue.directives 注册全局指令或是在组件的 options 里添加 directives 属性。前者接受两个参数，第一个参数是指令名，第二个参数是定义指令的值（可以是一个包含指令各个 hooks 的函数的对象或者是一个只对 bind 和 update hook 生效的简写函数），后者是一个包含以指令名为属性以及对应定义指令的值为值的对象。
指令 hook 函数和对应参数 定义指令的对象包括 bind、inserted、update、componentUpdated、unbind 五个 hook，每个 hook 对应一个在对应时机执行的函数，函数的参数为：
 el：含指令所绑定的 DOM 元素 binding：包含指令相关信息（包括指令名、绑定值、绑定的参数、修饰符等）的对象 vnode：指令被解析为其 data.directives 属性的 vnode oldVnode：更新前的 vnode，仅在 update、componentUpdated 有值  可以猜测指令只在一般组件和 HTML 元素上生效，而在函数式组件和像 template、slot、component 对应的标签以及 keep-alive、transition 这样 abstract 组件上不生效的，因为指令 hook 的第一个参数是一个 DOM 元素，后面的几种情况并不能永远确定一个唯一的 el 传给 hook。事实上通过从源码粗略搜索关键字也可以确认不适用指令的情况中，指令对应的 vnode.data.directives 并未被处理。
指令的大致机制 指令注册的机制 就是通过 Vue.directives 和 options.directives API 使得某个组件可以通过 vm.$options.directives.directiveName 可以访问到对应的指令对象。
指令作用的机制 通过搜索 directives 在 vdom 相关的模块可以知道「指令是通过 vdom 的 module 机制生效的」。vdom 的 module 是用于处理 vdom 的各种 attribute 的机制，比如 style、class、events 等，这些 module 如同定义指令的对象一样也是一个由一个个 hook 名和对应函数值组成的对象，只不过 module 的 hook 是 vdom 的 hook。通过在 vdom 的 hook 里触发指令对应的 hook 从而使指令生效。而触发指令 hook 的时对应函数的第二个参数 binding 相关的信息则由通过 template 模板编译（或是手写 render 直接传参）而来的 vnode.]]></description>
</item>
<item>
    <title>Vue2.6 slot 笔记</title>
    <link>https://moshimoshi.top/posts/vue-slot-%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Tue, 21 Sep 2021 21:07:57 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vue-slot-%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[什么是 slot？——精确的定义不好下，可以类比为电脑主板上用于插网卡、内存条等各种硬件的那些东西。因为有那些插槽，人们可以在上面插上不同的网卡和内存条。
slot 有什么用？——先设想，如果没有 slot，那些硬件就必须集成在主板上，显然不是一种灵活的做法，slot 就赋予了这种灵活性。
拿电脑主板打比方后，Vue 的 slot 的作用也就是一样的：赋予组件直接将 vnode 填充到组件的渲染内容中特定地方的能力。slot 相关的用法 Vue 文档有详述，本篇主要记录 slot 的实现原理，v2.6 之前的 slot attribute 的即将废弃的写法不作讨论，主要说明 v-slot 写法的 slot。
renderSlot 先从有 slot 的组件的 render 方法说起，比如下面的组件：
&lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Hello' } &lt;/script&gt; 的 render 函数会是：
function() { var _vm = this var _h = _vm.$createElement var _c = _vm._self._c || _h return _c(&quot;div&quot;, [_vm._t(&quot;default&quot;)], 2) } 其中 _vm._t 就是 renderSlot]]></description>
</item>
<item>
    <title>Vue2 函数式组件</title>
    <link>https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/</link>
    <pubDate>Sun, 12 Sep 2021 21:30:42 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/</guid>
    <description><![CDATA[函数式组件简介  何为函数式组件？——当组件对应的 options 对象中 functional 属性值为 true 时，这个组件就是一个函数式组件 函数式组件与一般组件有何不同？——它没有响应式的数据（组件对应的 options 里没有 data、computed 等与 state 相关的属性）；也不像一般组件一样有通过 options 创建的 vm 实例（自然也没有那一系列的生命周期），所以在函数式组件内部的方法中也没有 this 可以访问，它所拥有的只是一个包含 props、children、slots、scopedSlots、parent、listeners、injections 属性的 functionalRenderContext 对象，这个对象供函数式组件的 render 方法访问，以达到父组件向其传值以及访问函数式组件渲染内容的目的 为什么要有函数式组件？——有些时候一个组件并不需要创建和维护自己的内部状态，而只用完全根据 props 的值来决定渲染的内容，创建 vm 会略显多余，此时则是函数式组件的用武之地，相比于创建 vm 实例并执行一系列生命周期 hooks，创建一个 functionalRenderContext 对象的开销则小得多  函数式组件内部机制 不管是何种组件，调用自身 render 方法的结果都是返回一个 vnode 实例用于 patch，函数式组件也不例外，与一般组件的 render 方法不同的是函数式组件的 render 方法多了个 functionalRenderContext 对象用来弥补没有与之对应的 vm 实例所带来的的不足：没有内部状态固然不用创建 vm，但与此同时 props、children 之类的东西也没了。所以函数式组件的内部机制主要在于 functionalRenderContext 对象的创建，也即对象包含的属性的创建。与函数式组件相关的源码大致如下：
function createComponent(Ctor, data, context, children, tag) { // ... const propsData = extractPropsFromVNodeData(data, Ctor, tag) if (Ctor.]]></description>
</item>
<item>
    <title>从 new Vue 到所有组件 mounted</title>
    <link>https://moshimoshi.top/posts/new-vue%E5%88%B0%E6%89%80%E6%9C%89%E7%BB%84%E4%BB%B6mounte/</link>
    <pubDate>Sun, 15 Nov 2020 17:40:32 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/new-vue%E5%88%B0%E6%89%80%E6%9C%89%E7%BB%84%E4%BB%B6mounte/</guid>
    <description><![CDATA[前言 在开始本篇之前：
  本篇的主要目的在于理解 mounted 的大致原理（mounted 之后的事不在本篇讨论之内）
  所用的 Vue 版本是 2.6.11，借以帮助理解的例子是 vue-cli 创建的简单 demo
  暂不理会包括但不仅限于 slot、函数式组件、服务端渲染以及其他一些不影响理解的特性
  贴出的代码并不完全与源码一模一样，在没有错误的前提下会有一些改动和删减（笔者认为这样做有助于理解）
  也不会逐行去解释代码，未提到的部分可以认为暂时不提也无大碍（如果真的不是因为粗心的话）
  然后，本篇所用的实例代码如下：
main.js
import Vue from &#39;vue&#39; import App from &#39;./App&#39; new Vue({ render: h =&gt; h(App) }).mount(&#39;#app&#39;) App.vue
&lt;template&gt; &lt;div&gt; &lt;div&gt;hello, {{ msg }}&lt;/div&gt; &lt;home&gt;&lt;/home&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import home from &#39;./home&#39; export default { name: &#39;App&#39;, components: { home }, data() { return { msg: &#39;app&#39; } } } &lt;/script&gt; home.]]></description>
</item>
<item>
    <title>Vue 应用部署在非根路径</title>
    <link>https://moshimoshi.top/posts/vue-%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E9%9D%9E%E6%A0%B9%E8%B7%AF%E5%BE%84/</link>
    <pubDate>Thu, 15 Oct 2020 17:40:32 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vue-%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E9%9D%9E%E6%A0%B9%E8%B7%AF%E5%BE%84/</guid>
    <description><![CDATA[注：此处 Vue App 指的是由 Vue-CLI 3 创建的单页面应用，部署应用的 Web 服务器为 Nginx。
正文 谈到部署前端应用，大概所有有过相关经历的开发者都不会对这个流程感到陌生：npm run build -&gt; dist 目录整个 copy （手动、脚本或 devops 流水线）到对应 Web 服务器的指定目录。
然后在浏览器上输入服务器的地址（不需要任何路径）就可以访问到部署的那个应用了，在应用里面，你也只是按照后台开发给你 API 路径（大概率是个不包括服务器地址的绝对路径）去请求对应的数据，好像也没有做什么特殊的事情，应用完全运行正常。
这一切看起来十分的自然和理所应当，后面你又以相同的方式开发、部署了多个类似的应用，这种在根路径上的部署，对你来说轻车熟路，一切都很顺利。直到有一天，因为防火墙、或者资金紧张或者其他随便的什么原因，你们所有那些应用在公网上全都只能通过某一台服务器（假设叫 outer）访问了，也就是说原先可以分别通过 http://addressN （N = 1, 2, 3&hellip;）被  访问的各个应用，现在只能通过 http://address/appN/ 来访问了。这个时候，你想了想好像跟之前没什么区别，（拿 app1 举例）只不过原先部署到 http://address1 的 app1 只能换个内部的服务器（假设叫 inner1）部署了，然后在你重新部署了之后，负责配置 http://address 服务器 Nginx 的人告诉你：我把所有 /app1/ 开头的请求都转到 inner1 上了，你现在看下通过 http://address/app1/ 是不是能访问到 app1。
你内心感觉应该没什么问题地在浏览器上访问了那个地址：浏览器 Tab 条上 app1 的页面 title 出来了，但是整个页面一片空白。然后你很熟练地打开了控制台的 Network 发现，那些 js 和 css 资源都是 404，你很快的察觉到原因是由于这些资源的路径有问题，它们的格式分别是 /js/xx.]]></description>
</item>
</channel>
</rss>
