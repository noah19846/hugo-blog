<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Vue - Category - Kisama&#39;s Blog</title>
        <link>https://moshimoshi.top/categories/vue/</link>
        <description>Vue - Category - Kisama&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 26 Mar 2022 10:22:06 &#43;0000</lastBuildDate><atom:link href="https://moshimoshi.top/categories/vue/" rel="self" type="application/rss+xml" /><item>
    <title>vite 项目中 debug vue3.x 源码</title>
    <link>https://moshimoshi.top/posts/vite-%E9%A1%B9%E7%9B%AE%E4%B8%AD-debug-vue3.x-%E6%BA%90%E7%A0%81/</link>
    <pubDate>Sat, 26 Mar 2022 10:22:06 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vite-%E9%A1%B9%E7%9B%AE%E4%B8%AD-debug-vue3.x-%E6%BA%90%E7%A0%81/</guid>
    <description><![CDATA[之前在 vue-cli 创建的项目中调试 Vue2.x 源码时，只修改 package.json 中 module 字段对应的文件内容，对应的改动就会在浏览器刷新后体现出来，但这在由 vite 创建的 vue3.x 的项目中却行不通，原因有三：
 vue3.x 是一个 monorepo，源码被分成了好几部分 vite 的 pre-bundle 机制 vite 设置的浏览器缓存机制  后面两个好解决，只需分别将创建 viteServer 的 server.force 设置为 true（即将 package.json 里 scripts 中 &quot;dev&quot;: &quot;vite&quot; 改为 &quot;dev&quot;: &quot;vite --forece&quot;） 和浏览器控制台 network 栏激活 Disable cache 即可，这两步完成之后其实就可以在浏览器中调试源码了：
 修改 vue3.x package.json 中 module 字段对应的文件，以及其 dependencies 的 package.json 中 module 字段对应的文件 在编辑器中手动保存（不用任何改动，只在那个文件窗口下 cmd + s 即可）一下 vite.config.js 文件  这两步之后即可看到源码中的改动体现在浏览器中了，所以，这就完了？
当然不是，天知道每次改动一个文件之后还要再到另一个文件窗口中按一下 cmd + s 才能让浏览器刷新有多憨批，所以自动保存 vite.]]></description>
</item>
<item>
    <title>vue2 自定义指令笔记以及在埋点上的简单应用</title>
    <link>https://moshimoshi.top/posts/vue2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%9F%8B%E7%82%B9%E4%B8%8A%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</link>
    <pubDate>Sat, 25 Sep 2021 17:19:36 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://moshimoshi.top/posts/vue2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%9F%8B%E7%82%B9%E4%B8%8A%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</guid>
    <description><![CDATA[简介 Vue 允许开发者注册自定义指令，可以是通过 Vue.directives 注册全局指令或是在组件的 options 里添加 directives 属性。前者接受两个参数，第一个参数是指令名，第二个参数是定义指令的值（可以是一个包含指令各个 hooks 的函数的对象或者是一个只对 bind 和 update hook 生效的简写函数），后者是一个包含以指令名为属性以及对应定义指令的值为值的对象。
指令 hook 函数和对应参数 定义指令的对象包括 bind、inserted、update、componentUpdated、unbind 五个 hook，每个 hook 对应一个在对应时机执行的函数，函数的参数为：
 el：含指令所绑定的 DOM 元素 binding：包含指令相关信息（包括指令名、绑定值、绑定的参数、修饰符等）的对象 vnode：指令被解析为其 data.directives 属性的 vnode oldVnode：更新前的 vnode，仅在 update、componentUpdated 有值  可以猜测指令只在一般组件和 HTML 元素上生效，而在函数式组件和像 template、slot、component 对应的标签以及 keep-alive、transition 这样 abstract 组件上不生效的，因为指令 hook 的第一个参数是一个 DOM 元素，后面的几种情况并不能永远确定一个唯一的 el 传给 hook。事实上通过从源码粗略搜索关键字也可以确认不适用指令的情况中，指令对应的 vnode.data.directives 并未被处理。
指令的大致机制 指令注册的机制 就是通过 Vue.directives 和 options.directives API 使得某个组件可以通过 vm.$options.directives.directiveName 可以访问到对应的指令对象。
指令作用的机制 通过搜索 directives 在 vdom 相关的模块可以知道「指令是通过 vdom 的 module 机制生效的」。vdom 的 module 是用于处理 vdom 的各种 attribute 的机制，比如 style、class、events 等，这些 module 如同定义指令的对象一样也是一个由一个个 hook 名和对应函数值组成的对象，只不过 module 的 hook 是 vdom 的 hook。通过在 vdom 的 hook 里触发指令对应的 hook 从而使指令生效。而触发指令 hook 的时对应函数的第二个参数 binding 相关的信息则由通过 template 模板编译（或是手写 render 直接传参）而来的 vnode.]]></description>
</item>
</channel>
</rss>
