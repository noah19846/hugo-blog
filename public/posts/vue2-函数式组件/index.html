<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Vue2 函数式组件 - Kisama&#39;s Blog</title><meta name="Description" content="This is my cool site"><meta property="og:title" content="Vue2 函数式组件" />
<meta property="og:description" content="函数式组件简介  何为函数式组件？——当组件对应的 options 对象中 functional 属性值为 true 时，这个组件就是一个函数式组件 函数式组件与一般组件有何不同？——它没有响应式的数据（组件对应的 options 里没有 data、computed 等与 state 相关的属性）；也不像一般组件一样有通过 options 创建的 vm 实例（自然也没有那一系列的生命周期），所以在函数式组件内部的方法中也没有 this 可以访问，它所拥有的只是一个包含 props、children、slots、scopedSlots、parent、listeners、injections 属性的 functionalRenderContext 对象，这个对象供函数式组件的 render 方法访问，以达到父组件向其传值以及访问函数式组件渲染内容的目的 为什么要有函数式组件？——有些时候一个组件并不需要创建和维护自己的内部状态，而只用完全根据 props 的值来决定渲染的内容，创建 vm 会略显多余，此时则是函数式组件的用武之地，相比于创建 vm 实例并执行一系列生命周期 hooks，创建一个 functionalRenderContext 对象的开销则小得多  函数式组件内部机制 不管是何种组件，调用自身 render 方法的结果都是返回一个 vnode 实例用于 patch，函数式组件也不例外，与一般组件的 render 方法不同的是函数式组件的 render 方法多了个 functionalRenderContext 对象用来弥补没有与之对应的 vm 实例所带来的的不足：没有内部状态固然不用创建 vm，但与此同时 props、children 之类的东西也没了。所以函数式组件的内部机制主要在于 functionalRenderContext 对象的创建，也即对象包含的属性的创建。与函数式组件相关的源码大致如下：
function createComponent(Ctor, data, context, children, tag) { // ... const propsData = extractPropsFromVNodeData(data, Ctor, tag) if (Ctor." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/" />
<meta property="article:published_time" content="2021-09-12T21:30:42+00:00" />
<meta property="article:modified_time" content="2021-09-12T21:30:42+00:00" /><meta property="og:site_name" content="My cool site" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vue2 函数式组件"/>
<meta name="twitter:description" content="函数式组件简介  何为函数式组件？——当组件对应的 options 对象中 functional 属性值为 true 时，这个组件就是一个函数式组件 函数式组件与一般组件有何不同？——它没有响应式的数据（组件对应的 options 里没有 data、computed 等与 state 相关的属性）；也不像一般组件一样有通过 options 创建的 vm 实例（自然也没有那一系列的生命周期），所以在函数式组件内部的方法中也没有 this 可以访问，它所拥有的只是一个包含 props、children、slots、scopedSlots、parent、listeners、injections 属性的 functionalRenderContext 对象，这个对象供函数式组件的 render 方法访问，以达到父组件向其传值以及访问函数式组件渲染内容的目的 为什么要有函数式组件？——有些时候一个组件并不需要创建和维护自己的内部状态，而只用完全根据 props 的值来决定渲染的内容，创建 vm 会略显多余，此时则是函数式组件的用武之地，相比于创建 vm 实例并执行一系列生命周期 hooks，创建一个 functionalRenderContext 对象的开销则小得多  函数式组件内部机制 不管是何种组件，调用自身 render 方法的结果都是返回一个 vnode 实例用于 patch，函数式组件也不例外，与一般组件的 render 方法不同的是函数式组件的 render 方法多了个 functionalRenderContext 对象用来弥补没有与之对应的 vm 实例所带来的的不足：没有内部状态固然不用创建 vm，但与此同时 props、children 之类的东西也没了。所以函数式组件的内部机制主要在于 functionalRenderContext 对象的创建，也即对象包含的属性的创建。与函数式组件相关的源码大致如下：
function createComponent(Ctor, data, context, children, tag) { // ... const propsData = extractPropsFromVNodeData(data, Ctor, tag) if (Ctor."/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/" /><link rel="prev" href="https://moshimoshi.top/posts/x86-32-%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/" /><link rel="next" href="https://moshimoshi.top/posts/vue-slot-%E7%AC%94%E8%AE%B0/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Vue2 函数式组件",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/moshimoshi.top\/posts\/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6\/"
        },"genre": "posts","keywords": "Vue, 函数式组件","wordcount":  423 ,
        "url": "https:\/\/moshimoshi.top\/posts\/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6\/","datePublished": "2021-09-12T21:30:42+00:00","dateModified": "2021-09-12T21:30:42+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Author"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Kisama&#39;s Blog">My cool site</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Kisama&#39;s Blog">My cool site</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Vue2 函数式组件</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Author</a></span>&nbsp;<span class="post-category">included in <a href="/categories/%E5%89%8D%E7%AB%AF/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>前端</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2021-09-12">2021-09-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;423 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;2 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#函数式组件简介">函数式组件简介</a></li>
    <li><a href="#函数式组件内部机制">函数式组件内部机制</a></li>
    <li><a href="#一个直接将-vnode-写在-template-里的想法">一个直接将 vnode 写在 template 里的想法</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="函数式组件简介">函数式组件简介</h2>
<ol>
<li>何为函数式组件？——当组件对应的 options 对象中 <em>functional</em> 属性值为 <em>true</em> 时，这个组件就是一个函数式组件</li>
<li>函数式组件与一般组件有何不同？——它没有响应式的数据（组件对应的 options 里没有 <em>data</em>、<em>computed</em> 等与 state 相关的属性）；也不像一般组件一样有通过 options 创建的 vm 实例（自然也没有那一系列的生命周期），所以在函数式组件内部的方法中也没有 <em>this</em> 可以访问，它所拥有的只是一个包含 <em>props</em>、<em>children</em>、<em>slots</em>、<em>scopedSlots</em>、<em>parent</em>、<em>listeners</em>、<em>injections</em> 属性的 <em>functionalRenderContext</em> 对象，这个对象供函数式组件的 <em>render</em> 方法访问，以达到父组件向其传值以及访问函数式组件渲染内容的目的</li>
<li>为什么要有函数式组件？——有些时候一个组件并不需要创建和维护自己的内部状态，而只用完全根据 <em>props</em> 的值来决定渲染的内容，创建 vm 会略显多余，此时则是函数式组件的用武之地，相比于创建 vm 实例并执行一系列生命周期 hooks，创建一个 <em>functionalRenderContext</em> 对象的开销则小得多</li>
</ol>
<h2 id="函数式组件内部机制">函数式组件内部机制</h2>
<p>不管是何种组件，调用自身 render 方法的结果都是返回一个 vnode 实例用于 patch，函数式组件也不例外，与一般组件的 render 方法不同的是函数式组件的 render 方法多了个 <em>functionalRenderContext</em> 对象用来弥补没有与之对应的 vm 实例所带来的的不足：没有内部状态固然不用创建 vm，但与此同时 <em>props</em>、<em>children</em> 之类的东西也没了。所以函数式组件的内部机制主要在于 <em>functionalRenderContext</em> 对象的创建，也即对象包含的属性的创建。与函数式组件相关的源码大致如下：</p>
<pre><code>function createComponent(Ctor, data, context, children, tag) {
  // ...
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  if (Ctor.options.functional === true) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }
  // ...
}

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  const options = Ctor.options;
  const props = {};
  const propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject)
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs)
    }
    if (isDef(data.props)) {
      mergeProps(props, data.props)
    }
  }
  const renderContext = new FunctionRenderContext(data, props, children, contextVm, Ctor)

  const vnode = Ctor.options.render.call(null, renderContext._c, renderContext)

  return vnode
}

function FunctionRenderContext(data, props, children, parent, Ctor) {
  const options = Ctor.options
  let contextVm

  if (hasOwn(parent, '_uid')) {
    // 说明要渲染的函数组件是在一般组件里渲染的
    contextVm = Object.create(parent)
    contextVm._original = parent
  } else {
    // 说明要渲染的函数组件是在另一个函数组件里渲染的
    contextVm = parent
    parent = parent._origin
  }

  this.data = data
  this.props = props
  this.children = children
  this.listeners = data.on || emptyObject
  this.injections = resolveInjections(options.inject, parent)
  this.slots = () =&gt; { // ... 一个返回 slots 对象的函数 }
  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    function get() {
      // 返回 scopedSlots 对象
    }
  })

  this._c = (a, b, c, d) =&gt; createElement(contextVm, a, b, c, d)
}

installRenderHelpers(FunctionalRenderContext.prototype)
</code></pre><p>可以看到在由某个一般组件开始 render 进而执行 <em>createComponent</em> 函数之前，作为那个一般组件的子组件的函数式组件得到的待遇与一般组件区别无二，只在真正开始创建 vnode 实例时才执行不同的逻辑，即 <code>return createFunctionalComponent(Ctor, propsData, data, context, children)</code>，其内部执行步骤如下：</p>
<ol>
<li>如果函数式组件对应的 options 里有定义 <em>props</em>，那么依据其和 <em>propsData</em> 生成一个 props 对象，否则将 <code>data.attrs</code> 和 <code>data.props</code> 合并生成一个 props 对象</li>
<li>通过 <code>new FunctionalRenderContext(data, props, children, contextVm, Ctor)</code> 生成 <em>renderContext</em> 实例，其中 <em>props</em> 为 step1 生成的对象</li>
<li>调用 <code>options.render.call(null, renderContext._c, renderContext)</code> 生成 vnode</li>
<li>返回 step3 生成的 vnode</li>
</ol>
<p><em>FunctionalRenderContext</em> 构造函数的内部则根据传的参数生成包含前面所述那些属性的实例，其内部步骤如下：</p>
<ol>
<li>依据 <em>parent</em> 是一般组件还是也是函数式组件确定对应的 <em>contextVm</em>，用于传给 <em>createElement</em></li>
<li>为  实例确定 <em>props</em>、<em>children</em>、<em>slots</em>、<em>scopedSlots</em>、<em>parent</em>、<em>listeners</em>、<em>injections</em> 属性的值</li>
<li>为实例添加 <em>_c</em> 方法，用于传给 <code>options.render</code> 方法的第一个参数</li>
</ol>
<p><code>installRenderHelpers(FunctionalRenderContext.prototype)</code> 的作用是为之添加一些由 <code>&lt;template functional&gt;&lt;/template&gt;</code> 编译而成的 render 函数内部可能会用到的 render helpers，与添加到 <code>Vue.prototype</code> 上的完全一致。</p>
<p>源码中关于函数式组件相关的内容就是这些，因为不生成 vm，所以流程比较简单，就是根据父组件可能会传的那几个属性以及可能会有的 children 来生成对应的 vnode 然后静待 patch 到 dom 上即可。而不像一般 vm 那样需要预生成一个安装了 vnode hooks 的 placeholder vnode，然后在 patch 时在已安装的 vnode hooks 里生成对应的 vm 实例继而 vm 实例再 render。</p>
<h2 id="一个直接将-vnode-写在-template-里的想法">一个直接将 vnode 写在 template 里的想法</h2>
<p>虽然没了 vm，单函数式组件还是多创建了个 <em>functionalRenderContext</em> 实例以及对应的 <em>contextVm</em> 实例，有没有办法把这两个开销也省掉呢？比如直接把 vnode 写在 template 里的。</p>
<p>目前 Vue 好像没有这样的 api 或组件提供这样的功能，虽然有 dynamic component，但这个组件的花销还是不少于创建一个函数组件的花销。如果 Vue 提供可以直接将 vnode 写到 template 里的功能会是什么样？</p>
<p>比如提供一个名为 vnode 的内置组件，compiler 会把 vnode 组件中 <code>{{}}</code> 里的东西当成 vnode 来处理，即 <code>&lt;div&gt;&lt;vnode&gt;{{</code> <code>aVnodeOrVnodeArray</code> <code>}}&lt;/vnode&gt;&lt;/div&gt;</code> 这样的模板内容在 render 方法中会被编译成 <code>vm._c('div', null, aVnodeOrVnodeArray)</code>，这样的话在 render 时就不会创建不必要的 <em>contextVm</em> 和 <em>functionalRenderContext</em> 实例了，因为 <strong>aVnodeOrVnodeArray</strong> 已经是 vnode 了。<strong>aVnodeOrVnodeArray</strong> 应该可以是依赖 data 或是 props 的某个 computed value，也可以是某个 method 的返回值。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2021-09-12</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/" data-title="Vue2 函数式组件" data-hashtags="Vue,函数式组件"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/" data-hashtag="Vue"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/" data-title="Vue2 函数式组件"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/" data-title="Vue2 函数式组件"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://moshimoshi.top/posts/vue2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/" data-title="Vue2 函数式组件"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/vue/">Vue</a>,&nbsp;<a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/">函数式组件</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/x86-32-%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/" class="prev" rel="prev" title="x86 32 位保护模式笔记"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>x86 32 位保护模式笔记</a>
            <a href="/posts/vue-slot-%E7%AC%94%E8%AE%B0/" class="next" rel="next" title="Vue2.6 slot 笔记">Vue2.6 slot 笔记<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.68.3">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
